{
  "chunk_id": "wrapError_deep_dive_advanced-usage-patterns",
  "title": "Advanced Usage Patterns",
  "content": "## Advanced Usage Patterns\n\n### Error Chaining\n\n```typescript\n// Create error chain with preserved causation\nfunction processPayment(paymentData: PaymentData) {\n try {\n // Step 1: Validate payment data\n const validatedData = validatePaymentData(paymentData);\n\n // Step 2: Process with payment provider\n return processWithStripe(validatedData);\n } catch (error) {\n // Wrap validation errors\n if (error.name === \"ValidationError\") {\n return wrapError(\n \"PaymentValidationError\",\n error,\n \"Payment data validation failed\",\n {\n paymentMethod: paymentData.method,\n amount: paymentData.amount,\n currency: paymentData.currency,\n }\n );\n }\n\n // Wrap provider errors\n if (error.name === \"StripeError\") {\n return wrapError(\n \"PaymentProviderError\",\n error,\n \"Payment provider rejected the transaction\",\n {\n provider: \"stripe\",\n errorCode: error.code,\n paymentIntent: error.payment_intent?.id,\n }\n );\n }\n\n // Wrap unknown errors\n return wrapError(\n \"PaymentProcessingError\",\n error,\n \"Unexpected error during payment processing\",\n {\n paymentId: paymentData.id,\n step: \"unknown\",\n }\n );\n }\n}\n```\n\n### Multi-Level Error Wrapping\n\n```typescript\n// Service layer\nclass UserService {\n async getUser(id: string) {\n try {\n const user = await this.repository.findById(id);\n return user;\n } catch (error) {\n return wrapError(\n \"UserServiceError\",\n error,\n \"Failed to retrieve user from service\",\n {\n userId: id,\n service: \"UserService\",\n method: \"getUser\",\n }\n );\n }\n }\n}\n\n// Repository layer\nclass UserRepository {\n async findById(id: string) {\n try {\n const result = await this.database.query(\n \"SELECT * FROM users WHERE id = ?\",\n [id]\n );\n return result[0];\n } catch (error) {\n return wrapError(\"DatabaseError\", error, \"Database query failed\", {\n table: \"users\",\n operation: \"SELECT\",\n userId: id,\n });\n }\n }\n}\n\n// Controller layer\nclass UserController {\n async handleGetUser(req: Request, res: Response) {\n const result = await this.userService.getUser(req.params.id);\n\n if (isTryError(result)) {\n // Error chain: Controller -> Service -> Repository -> Database\n const controllerError = wrapError(\n \"ControllerError\",\n result,\n \"Failed to handle user request\",\n {\n requestId: req.id,\n endpoint: req.path,\n method: req.method,\n userId: req.params.id,\n }\n );\n\n return res.status(500).json({\n error: controllerError.message,\n type: controllerError.type,\n requestId: req.id,\n });\n }\n\n return res.json(result);\n }\n}\n```\n\n### Third-Party Integration Patterns\n\n```typescript\n// Axios integration\nasync function makeApiRequest(url: string, options: RequestOptions) {\n try {\n const response = await axios.get(url, options);\n return response.data;\n } catch (error) {\n if (axios.isAxiosError(error)) {\n return wrapError(\n \"ApiError\",\n error,\n `API request failed: ${error.response?.status} ${error.response?.statusText}`,\n {\n url,\n method: options.method || \"GET\",\n status: error.response?.status,\n responseData: error.response?.data,\n requestId: options.headers?.[\"x-request-id\"],\n }\n );\n }\n\n return wrapError(\"UnknownApiError\", error, \"Unexpected API error\");\n }\n}\n\n// AWS SDK integration\nasync function uploadToS3(bucket: string, key: string, body: Buffer) {\n try {\n const result = await s3\n .upload({\n Bucket: bucket,\n Key: key,\n Body: body,\n })\n .promise();\n\n return result.Location;\n } catch (error) {\n return wrapError(\"S3Error\", error, \"Failed to upload file to S3\", {\n bucket,\n key,\n fileSize: body.length,\n region: s3.config.region,\n errorCode: error.code,\n errorMessage: error.message,\n });\n }\n}\n\n// Database integration (MongoDB)\nasync function findUserInMongo(userId: string) {\n try {\n const user = await User.findById(userId);\n if (!user) {\n throw new Error(`User not found: ${userId}`);\n }\n return user;\n } catch (error) {\n if (error.name === \"CastError\") {\n return wrapError(\"InvalidUserIdError\", error, \"Invalid user ID format\", {\n userId,\n expectedFormat: \"ObjectId\",\n providedFormat: typeof userId,\n });\n }\n\n if (error.name === \"MongoError\") {\n return wrapError(\n \"DatabaseConnectionError\",\n error,\n \"Database connection failed\",\n {\n database: \"users\",\n operation: \"findById\",\n errorCode: error.code,\n }\n );\n }\n\n return wrapError(\n \"UserLookupError\",\n error,\n \"Failed to find user in database\",\n { userId }\n );\n }\n}\n```\n\n### Framework-Specific Patterns\n\n```typescript\n// Express.js middleware\nfunction errorWrapperMiddleware(\n req: Request,\n res: Response,\n next: NextFunction\n) {\n const originalSend = res.send;\n\n res.send = function (body) {\n if (isTryError(body)) {\n const requestError = wrapError(\n \"RequestError\",\n body,\n \"Request processing failed\",\n {\n requestId: req.id,\n path: req.path,\n method: req.method,\n userAgent: req.get(\"User-Agent\"),\n timestamp: Date.now(),\n }\n );\n\n return originalSend.call(this, {\n error: requestError.message,\n type: requestError.type,\n requestId: req.id,\n });\n }\n\n return originalSend.call(this, body);\n };\n\n next();\n}\n\n// React error boundary integration\nclass ErrorBoundary extends React.Component {\n componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n const wrappedError = wrapError(\n \"ReactError\",\n error,\n \"React component error occurred\",\n {\n componentStack: errorInfo.componentStack,\n errorBoundary: this.constructor.name,\n timestamp: Date.now(),\n }\n );\n\n // Send to error reporting service\n errorReportingService.captureError(wrappedError);\n }\n}\n\n// Next.js API route\nexport default async function handler(\n req: NextApiRequest,\n res: NextApiResponse\n) {\n try {\n const result = await processApiRequest(req.body);\n return res.status(200).json(result);\n } catch (error) {\n const apiError = wrapError(\n \"NextApiError\",\n error,\n \"API route processing failed\",\n {\n route: req.url,\n method: req.method,\n query: req.query,\n timestamp: Date.now(),\n }\n );\n\n return res.status(500).json({\n error: apiError.message,\n type: apiError.type,\n });\n }\n}\n```",
  "metadata": {
    "chunk_id": "wrapError_deep_dive_advanced-usage-patterns",
    "source_document": "rag-docs/wrapError-deep-dive.md",
    "chunk_type": "deep-dive-section",
    "last_updated": "2025-07-08T20:17:18.347Z",
    "topics": [
      "advanced usage patterns",
      "error chaining",
      "multi-level error wrapping",
      "third-party integration patterns",
      "framework-specific patterns",
      "typescript",
      "error",
      "async",
      "sync",
      "promise",
      "function",
      "method",
      "react",
      "component",
      "validation",
      "middleware"
    ],
    "complexity": "intermediate",
    "includes_code": true,
    "line_count": 308,
    "token_count": 875,
    "module": "errors",
    "category": "utilities",
    "search_keywords": [
      "processPayment",
      "validatePaymentData",
      "processWithStripe",
      "wrapError",
      "getUser",
      "findById",
      "query",
      "handleGetUser",
      "isTryError",
      "status",
      "json",
      "makeApiRequest",
      "get",
      "isAxiosError",
      "uploadToS3",
      "upload",
      "promise",
      "findUserInMongo",
      "Error",
      "errorWrapperMiddleware",
      "now",
      "call",
      "next",
      "componentDidCatch",
      "captureError",
      "handler",
      "processApiRequest",
      "PaymentData",
      "Validate",
      "Process",
      "Request",
      "Response",
      "Controller",
      "RequestOptions",
      "Buffer",
      "NextFunction",
      "Date",
      "React",
      "NextApiRequest",
      "NextApiResponse"
    ],
    "common_questions": [
      "How does advanced usage patterns work?",
      "Advanced Usage Patterns best practices",
      "Advanced Usage Patterns patterns"
    ],
    "id": "wrapError-deep-dive",
    "title": "wrapError() - Complete Implementation Guide",
    "tags": [
      "api",
      "core",
      "error-wrapping",
      "cause-preservation",
      "error-chaining"
    ],
    "related": [
      "fromThrown",
      "createError",
      "trySync",
      "tryAsync",
      "Error"
    ],
    "performance_impact": "low",
    "stability": "stable",
    "related_chunks": [
      "TryErrorBoundary_deep_dive_quick-reference",
      "TryErrorBoundary_deep_dive_signature",
      "TryErrorBoundary_deep_dive_purpose",
      "TryErrorBoundary_deep_dive_implementation-details",
      "TryErrorBoundary_deep_dive_basic-usage-examples",
      "TryErrorBoundary_deep_dive_advanced-usage-patterns",
      "TryErrorBoundary_deep_dive_hook-integration",
      "TryErrorBoundary_deep_dive_error-monitoring-integration",
      "TryErrorBoundary_deep_dive_testing-strategies",
      "TryErrorBoundary_deep_dive_performance-optimization"
    ],
    "related_functions": [],
    "usage_patterns": [
      "error-handling",
      "async-operations",
      "react-integration",
      "testing"
    ],
    "cross_references": [
      "TryErrorBoundary_deep_dive_advanced-usage-patterns",
      "fromThrown_deep_dive_advanced-usage-patterns",
      "function_Component",
      "function_Wrapper",
      "function_isTryError",
      "function_next",
      "function_validationError",
      "function_wrapError",
      "isTryError_deep_dive_advanced-usage-patterns",
      "useTry_deep_dive_advanced-usage-patterns"
    ]
  },
  "hash": "853aa53be4bc63f809305ef74cb7756c"
}