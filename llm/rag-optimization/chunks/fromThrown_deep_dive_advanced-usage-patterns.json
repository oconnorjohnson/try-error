{
  "chunk_id": "fromThrown_deep_dive_advanced-usage-patterns",
  "title": "Advanced Usage Patterns",
  "content": "## Advanced Usage Patterns\n\n### Error Type Discrimination\n\n```typescript\n// Type-safe error handling with discrimination\nfunction handleDatabaseOperation(operation: () => any) {\n try {\n return operation();\n } catch (error) {\n const wrappedError = fromThrown(error, {\n operation: operation.name,\n timestamp: Date.now(),\n });\n\n // Type-safe handling based on detected type\n switch (wrappedError.type) {\n case \"TypeError\":\n console.log(\"Type-related error:\", wrappedError.message);\n break;\n case \"ReferenceError\":\n console.log(\"Variable not found:\", wrappedError.message);\n break;\n case \"SyntaxError\":\n console.log(\"Syntax error:\", wrappedError.message);\n break;\n case \"Error\":\n console.log(\"Generic error:\", wrappedError.message);\n break;\n case \"StringError\":\n console.log(\"String error:\", wrappedError.message);\n break;\n case \"UnknownError\":\n console.log(\"Unknown error type:\", wrappedError.message);\n break;\n default:\n // TypeScript exhaustiveness check\n const _exhaustive: never = wrappedError.type;\n console.log(\"Unexpected error type:\", _exhaustive);\n }\n\n return wrappedError;\n }\n}\n```\n\n### Async Error Handling\n\n```typescript\n// Handle async errors with automatic detection\nasync function safeAsyncOperation<T>(operation: () => Promise<T>) {\n try {\n return await operation();\n } catch (error) {\n return fromThrown(error, {\n async: true,\n timestamp: Date.now(),\n });\n }\n}\n\n// Usage examples\nasync function fetchUserData(userId: string) {\n // Network errors\n const networkResult = await safeAsyncOperation(async () => {\n const response = await fetch(`/api/users/${userId}`);\n if (!response.ok) {\n throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n }\n return response.json();\n });\n\n if (isTryError(networkResult)) {\n console.log(networkResult.type); // \"Error\"\n console.log(networkResult.context.async); // true\n }\n\n // JSON parsing errors\n const parseResult = await safeAsyncOperation(async () => {\n const response = await fetch(`/api/users/${userId}`);\n return JSON.parse(await response.text());\n });\n\n if (isTryError(parseResult)) {\n console.log(parseResult.type); // \"SyntaxError\" (if JSON is invalid)\n }\n}\n```\n\n### Error Aggregation\n\n```typescript\n// Collect multiple errors with automatic type detection\nfunction processMultipleOperations(operations: (() => any)[]) {\n const results: any[] = [];\n const errors: TryError[] = [];\n\n for (const [index, operation] of operations.entries()) {\n try {\n results.push(operation());\n } catch (error) {\n errors.push(\n fromThrown(error, {\n operationIndex: index,\n operationName: operation.name,\n })\n );\n }\n }\n\n return {\n results,\n errors,\n errorsByType: groupErrorsByType(errors),\n };\n}\n\nfunction groupErrorsByType(errors: TryError[]): Record<string, TryError[]> {\n return errors.reduce((acc, error) => {\n if (!acc[error.type]) acc[error.type] = [];\n acc[error.type].push(error);\n return acc;\n }, {} as Record<string, TryError[]>);\n}\n\n// Usage\nconst operations = [\n () => JSON.parse('{\"valid\": true}'),\n () => JSON.parse(\"invalid json\"),\n () => {\n throw new TypeError(\"Type error\");\n },\n () => {\n throw \"String error\";\n },\n () => {\n throw { code: 500 };\n },\n];\n\nconst { results, errors, errorsByType } = processMultipleOperations(operations);\n\nconsole.log(errorsByType);\n// {\n// \"SyntaxError\": [TryError],\n// \"TypeError\": [TryError],\n// \"StringError\": [TryError],\n// \"UnknownError\": [TryError]\n// }\n```\n\n### Framework Integration Patterns\n\n```typescript\n// Express.js error handling\napp.use((err: any, req: Request, res: Response, next: NextFunction) => {\n const error = fromThrown(err, {\n url: req.url,\n method: req.method,\n headers: req.headers,\n timestamp: Date.now(),\n });\n\n // Type-specific handling\n const statusCode = getStatusCodeFromErrorType(error.type);\n\n res.status(statusCode).json({\n error: error.message,\n type: error.type,\n requestId: req.id,\n });\n});\n\nfunction getStatusCodeFromErrorType(type: string): number {\n switch (type) {\n case \"TypeError\":\n case \"ReferenceError\":\n case \"SyntaxError\":\n return 400; // Bad Request\n case \"Error\":\n return 500; // Internal Server Error\n case \"StringError\":\n return 422; // Unprocessable Entity\n case \"UnknownError\":\n return 500; // Internal Server Error\n default:\n return 500;\n }\n}\n\n// React error boundary\nclass ErrorBoundary extends React.Component<any, { error: TryError | null }> {\n constructor(props: any) {\n super(props);\n this.state = { error: null };\n }\n\n static getDerivedStateFromError(error: Error): { error: TryError } {\n return {\n error: fromThrown(error, {\n boundary: \"ErrorBoundary\",\n timestamp: Date.now(),\n }),\n };\n }\n\n componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n const wrappedError = fromThrown(error, {\n componentStack: errorInfo.componentStack,\n errorBoundary: this.constructor.name,\n });\n\n // Log to error service\n logErrorToService(wrappedError);\n }\n\n render() {\n if (this.state.error) {\n return (\n <div>\n <h2>Something went wrong</h2>\n <details>\n <summary>Error details</summary>\n <p>Type: {this.state.error.type}</p>\n <p>Message: {this.state.error.message}</p>\n <p>Context: {JSON.stringify(this.state.error.context, null, 2)}</p>\n </details>\n </div>\n );\n }\n\n return this.props.children;\n }\n}\n```\n\n### Testing Integration\n\n```typescript\n// Use in test helpers\nfunction expectError(operation: () => any, expectedType: string) {\n try {\n operation();\n throw new Error(\"Expected operation to throw\");\n } catch (error) {\n const wrappedError = fromThrown(error);\n expect(wrappedError.type).toBe(expectedType);\n return wrappedError;\n }\n}\n\n// Test examples\ndescribe(\"Error handling\", () => {\n it(\"should handle TypeError\", () => {\n const error = expectError(() => {\n const obj: any = null;\n return obj.someProperty;\n }, \"TypeError\");\n\n expect(error.message).toContain(\"Cannot read property\");\n });\n\n it(\"should handle ReferenceError\", () => {\n const error = expectError(() => {\n return (window as any).Variable;\n }, \"ReferenceError\");\n\n expect(error.message).toContain(\"not defined\");\n });\n\n it(\"should handle SyntaxError\", () => {\n const error = expectError(() => {\n return eval(\"invalid syntax\");\n }, \"SyntaxError\");\n\n expect(error.message).toContain(\"Unexpected\");\n });\n\n it(\"should handle string errors\", () => {\n const error = expectError(() => {\n throw \"String error\";\n }, \"StringError\");\n\n expect(error.message).toBe(\"String error\");\n });\n});\n```",
  "metadata": {
    "chunk_id": "fromThrown_deep_dive_advanced-usage-patterns",
    "source_document": "rag-docs/fromThrown-deep-dive.md",
    "chunk_type": "deep-dive-section",
    "last_updated": "2025-07-08T20:17:18.286Z",
    "topics": [
      "advanced usage patterns",
      "error type discrimination",
      "async error handling",
      "error aggregation",
      "framework integration patterns",
      "testing integration",
      "typescript",
      "error",
      "async",
      "sync",
      "promise",
      "function",
      "method",
      "react",
      "component",
      "testing"
    ],
    "complexity": "beginner",
    "includes_code": true,
    "line_count": 287,
    "token_count": 918,
    "module": "errors",
    "category": "utilities",
    "search_keywords": [
      "handleDatabaseOperation",
      "operation",
      "fromThrown",
      "now",
      "log",
      "fetchUserData",
      "safeAsyncOperation",
      "fetch",
      "Error",
      "json",
      "isTryError",
      "parse",
      "text",
      "processMultipleOperations",
      "entries",
      "push",
      "groupErrorsByType",
      "reduce",
      "TypeError",
      "use",
      "getStatusCodeFromErrorType",
      "status",
      "constructor",
      "super",
      "getDerivedStateFromError",
      "componentDidCatch",
      "logErrorToService",
      "render",
      "stringify",
      "expectError",
      "expect",
      "toBe",
      "describe",
      "it",
      "toContain",
      "eval",
      "Date",
      "TryError[]",
      "Record<string",
      "Request",
      "Response",
      "NextFunction",
      "TryError",
      "React"
    ],
    "common_questions": [
      "How does advanced usage patterns work?",
      "Advanced Usage Patterns best practices",
      "Advanced Usage Patterns patterns"
    ],
    "id": "fromThrown-deep-dive",
    "title": "fromThrown() - Complete Implementation Guide",
    "tags": [
      "api",
      "core",
      "auto-detection",
      "type-classification",
      "catch-blocks"
    ],
    "related": [
      "wrapError",
      "createError",
      "trySync",
      "tryAsync",
      "Error"
    ],
    "performance_impact": "low",
    "stability": "stable",
    "related_chunks": [
      "TryErrorBoundary_deep_dive_quick-reference",
      "TryErrorBoundary_deep_dive_signature",
      "TryErrorBoundary_deep_dive_purpose",
      "TryErrorBoundary_deep_dive_implementation-details",
      "TryErrorBoundary_deep_dive_basic-usage-examples",
      "TryErrorBoundary_deep_dive_advanced-usage-patterns",
      "TryErrorBoundary_deep_dive_hook-integration",
      "TryErrorBoundary_deep_dive_error-monitoring-integration",
      "TryErrorBoundary_deep_dive_testing-strategies",
      "TryErrorBoundary_deep_dive_performance-optimization"
    ],
    "related_functions": [],
    "usage_patterns": [
      "error-handling",
      "async-operations",
      "react-integration",
      "testing"
    ],
    "cross_references": [
      "TryErrorBoundary_deep_dive_advanced-usage-patterns",
      "create_error_deep_dive_usage-examples",
      "function_Component",
      "function_fetchUser",
      "function_fromThrown",
      "function_intern",
      "function_isTryError",
      "function_next",
      "isTryError_deep_dive_advanced-usage-patterns",
      "tryAsync_deep_dive_usage-examples",
      "trySync_deep_dive_usage-examples",
      "useTry_deep_dive_advanced-usage-patterns",
      "wrapError_deep_dive_advanced-usage-patterns"
    ]
  },
  "hash": "1cf33523bfe485a873d21cbcc6aa4fc4"
}