{
  "chunk_id": "useTry_deep_dive_advanced-usage-patterns",
  "title": "Advanced Usage Patterns",
  "content": "## Advanced Usage Patterns\n\n### Parallel Requests\n\n```typescript\nfunction Dashboard() {\n const {\n data: userData,\n error: userError,\n isLoading: userLoading,\n } = useTry(\n async (signal) => {\n const response = await fetch(\"/api/user\", { signal });\n return response.json();\n },\n {\n cacheKey: \"user-data\",\n cacheTime: 10 * 60 * 1000,\n }\n );\n\n const {\n data: statsData,\n error: statsError,\n isLoading: statsLoading,\n } = useTry(\n async (signal) => {\n const response = await fetch(\"/api/stats\", { signal });\n return response.json();\n },\n {\n cacheKey: \"stats-data\",\n cacheTime: 5 * 60 * 1000,\n }\n );\n\n const {\n data: notificationsData,\n error: notificationsError,\n isLoading: notificationsLoading,\n } = useTry(\n async (signal) => {\n const response = await fetch(\"/api/notifications\", { signal });\n return response.json();\n },\n {\n cacheKey: \"notifications-data\",\n cacheTime: 1 * 60 * 1000,\n }\n );\n\n const isAnyLoading = userLoading || statsLoading || notificationsLoading;\n const hasAnyError = userError || statsError || notificationsError;\n\n return (\n <div>\n {isAnyLoading && <div>Loading dashboard...</div>}\n {hasAnyError && <div>Some data failed to load</div>}\n\n {userData && (\n <section>\n <h2>User Profile</h2>\n {/* Render user data */}\n </section>\n )}\n\n {statsData && (\n <section>\n <h2>Statistics</h2>\n {/* Render stats */}\n </section>\n )}\n\n {notificationsData && (\n <section>\n <h2>Notifications</h2>\n {/* Render notifications */}\n </section>\n )}\n </div>\n );\n}\n```\n\n### Dependent Requests\n\n```typescript\nfunction UserOrdersComponent({ userId }: { userId: string }) {\n // First, fetch user data\n const {\n data: user,\n error: userError,\n isLoading: userLoading,\n } = useTry(\n async (signal) => {\n const response = await fetch(`/api/users/${userId}`, { signal });\n return response.json();\n },\n {\n deps: [userId],\n cacheKey: `user-${userId}`,\n }\n );\n\n // Then, fetch orders only when user is loaded\n const {\n data: orders,\n error: ordersError,\n isLoading: ordersLoading,\n } = useTry(\n async (signal) => {\n if (!user) return null;\n\n const response = await fetch(`/api/users/${user.id}/orders`, { signal });\n return response.json();\n },\n {\n enabled: !!user,\n deps: [user?.id],\n cacheKey: user ? `orders-${user.id}` : null,\n }\n );\n\n // Then, fetch order details for each order\n const {\n data: orderDetails,\n error: detailsError,\n isLoading: detailsLoading,\n } = useTry(\n async (signal) => {\n if (!orders || orders.length === 0) return [];\n\n const detailPromises = orders.map((order) =>\n fetch(`/api/orders/${order.id}/details`, { signal }).then((r) =>\n r.json()\n )\n );\n\n return Promise.all(detailPromises);\n },\n {\n enabled: !!orders && orders.length > 0,\n deps: [orders],\n cacheKey: orders\n ? `order-details-${orders.map((o) => o.id).join(\",\")}`\n : null,\n }\n );\n\n if (userLoading) return <div>Loading user...</div>;\n if (userError) return <div>Error loading user: {userError.message}</div>;\n if (!user) return <div>User not found</div>;\n\n if (ordersLoading) return <div>Loading orders...</div>;\n if (ordersError)\n return <div>Error loading orders: {ordersError.message}</div>;\n if (!orders || orders.length === 0) return <div>No orders found</div>;\n\n return (\n <div>\n <h1>{user.name}'s Orders</h1>\n\n {detailsLoading && <div>Loading order details...</div>}\n {detailsError && <div>Error loading details: {detailsError.message}</div>}\n\n {orders.map((order, index) => (\n <div key={order.id}>\n <h3>Order #{order.id}</h3>\n <p>Status: {order.status}</p>\n <p>Total: ${order.total}</p>\n\n {orderDetails && orderDetails[index] && (\n <div>\n <h4>Items:</h4>\n <ul>\n {orderDetails[index].items.map((item) => (\n <li key={item.id}>\n {item.name} - {item.quantity}x\n </li>\n ))}\n </ul>\n </div>\n )}\n </div>\n ))}\n </div>\n );\n}\n```\n\n### Infinite Scroll Pattern\n\n```typescript\nfunction InfiniteScrollList() {\n const [page, setPage] = useState(1);\n const [allItems, setAllItems] = useState<any[]>([]);\n\n const {\n data: pageData,\n error,\n isLoading,\n execute,\n } = useTry(\n async (signal) => {\n const response = await fetch(`/api/items?page=${page}&limit=20`, {\n signal,\n });\n\n if (!response.ok) throw new Error(\"Failed to fetch items\");\n return response.json();\n },\n {\n enabled: false,\n deps: [page],\n cacheKey: `items-page-${page}`,\n\n onSuccess: (data) => {\n if (page === 1) {\n setAllItems(data.items);\n } else {\n setAllItems((prev) => [...prev, ...data.items]);\n }\n },\n\n onError: (error) => {\n console.error(\"Failed to load page:\", error);\n },\n }\n );\n\n // Load first page on mount\n useEffect(() => {\n execute();\n }, [execute]);\n\n // Load more items\n const loadMore = () => {\n if (!isLoading && pageData?.hasMore) {\n setPage((prev) => prev + 1);\n }\n };\n\n // Intersection observer for automatic loading\n const loadMoreRef = useRef<HTMLDivElement>(null);\n\n useEffect(() => {\n const observer = new IntersectionObserver(\n (entries) => {\n if (entries[0].isIntersecting) {\n loadMore();\n }\n },\n { threshold: 1.0 }\n );\n\n if (loadMoreRef.current) {\n observer.observe(loadMoreRef.current);\n }\n\n return () => observer.disconnect();\n }, [loadMore]);\n\n return (\n <div>\n <h1>Items</h1>\n\n {allItems.map((item) => (\n <div key={item.id}>\n <h3>{item.name}</h3>\n <p>{item.description}</p>\n </div>\n ))}\n\n {isLoading && <div>Loading more items...</div>}\n {error && <div>Error: {error.message}</div>}\n\n {pageData?.hasMore && !isLoading && (\n <div ref={loadMoreRef} style={{ height: \"20px\" }}>\n {/* Intersection observer target */}\n </div>\n )}\n\n {pageData && !pageData.hasMore && <div>No more items to load</div>}\n </div>\n );\n}\n```\n\n### Real-time Updates\n\n```typescript\nfunction LiveDataComponent() {\n const [lastUpdate, setLastUpdate] = useState<Date | null>(null);\n const [autoRefresh, setAutoRefresh] = useState(true);\n\n const { data, error, isLoading, execute, abort } = useTry(\n async (signal) => {\n const response = await fetch(\"/api/live-data\", { signal });\n\n if (!response.ok) throw new Error(\"Failed to fetch live data\");\n return response.json();\n },\n {\n cacheKey: \"live-data\",\n staleTime: 0, // Always consider stale\n\n onSuccess: (data) => {\n setLastUpdate(new Date());\n },\n\n onError: (error) => {\n console.error(\"Live data update failed:\", error);\n },\n }\n );\n\n // Auto-refresh every 5 seconds\n useEffect(() => {\n if (!autoRefresh) return;\n\n const interval = setInterval(() => {\n execute();\n }, 5000);\n\n return () => clearInterval(interval);\n }, [autoRefresh, execute]);\n\n // Visibility change handling\n useEffect(() => {\n const handleVisibilityChange = () => {\n if (document.visibilityState === \"visible\" && autoRefresh) {\n execute();\n } else {\n abort();\n }\n };\n\n document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n return () =>\n document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n }, [execute, abort, autoRefresh]);\n\n return (\n <div>\n <div>\n <h1>Live Data</h1>\n\n <div>\n <button onClick={execute} disabled={isLoading}>\n {isLoading ? \"Refreshing...\" : \"Refresh Now\"}\n </button>\n\n <label>\n <input\n type=\"checkbox\"\n checked={autoRefresh}\n onChange={(e) => setAutoRefresh(e.target.checked)}\n />\n Auto-refresh\n </label>\n\n {isLoading && <button onClick={abort}>Cancel</button>}\n </div>\n\n {lastUpdate && <p>Last updated: {lastUpdate.toLocaleTimeString()}</p>}\n </div>\n\n {error && <div>Error: {error.message}</div>}\n\n {data && (\n <div>\n <h2>Current Data</h2>\n <pre>{JSON.stringify(data, null, 2)}</pre>\n </div>\n )}\n </div>\n );\n}\n```",
  "metadata": {
    "chunk_id": "useTry_deep_dive_advanced-usage-patterns",
    "source_document": "rag-docs/useTry-deep-dive.md",
    "chunk_type": "deep-dive-section",
    "last_updated": "2025-07-08T20:17:18.345Z",
    "topics": [
      "advanced usage patterns",
      "parallel requests",
      "dependent requests",
      "infinite scroll pattern",
      "real-time updates",
      "typescript",
      "error",
      "async",
      "sync",
      "promise",
      "function",
      "component"
    ],
    "complexity": "advanced",
    "includes_code": true,
    "line_count": 379,
    "token_count": 1141,
    "module": "react",
    "category": "utilities",
    "search_keywords": [
      "Dashboard",
      "useTry",
      "fetch",
      "json",
      "UserOrdersComponent",
      "map",
      "then",
      "all",
      "join",
      "InfiniteScrollList",
      "useState",
      "Error",
      "setAllItems",
      "error",
      "useEffect",
      "execute",
      "setPage",
      "IntersectionObserver",
      "loadMore",
      "observe",
      "disconnect",
      "LiveDataComponent",
      "setLastUpdate",
      "Date",
      "setInterval",
      "clearInterval",
      "abort",
      "addEventListener",
      "removeEventListener",
      "setAutoRefresh",
      "toLocaleTimeString",
      "stringify"
    ],
    "common_questions": [
      "How does advanced usage patterns work?",
      "Advanced Usage Patterns best practices",
      "Advanced Usage Patterns patterns"
    ],
    "id": "useTry-deep-dive",
    "title": "useTry() - Complete Implementation Guide",
    "tags": [
      "api",
      "react",
      "hooks",
      "async",
      "state-management",
      "cancellation",
      "caching"
    ],
    "related": [
      "tryAsync",
      "isTryError",
      "AbortSignal",
      "React",
      "useState",
      "useEffect"
    ],
    "performance_impact": "medium",
    "stability": "stable",
    "related_chunks": [
      "TryErrorBoundary_deep_dive_quick-reference",
      "TryErrorBoundary_deep_dive_signature",
      "TryErrorBoundary_deep_dive_purpose",
      "TryErrorBoundary_deep_dive_implementation-details",
      "TryErrorBoundary_deep_dive_basic-usage-examples",
      "TryErrorBoundary_deep_dive_advanced-usage-patterns",
      "TryErrorBoundary_deep_dive_hook-integration",
      "TryErrorBoundary_deep_dive_error-monitoring-integration",
      "TryErrorBoundary_deep_dive_testing-strategies",
      "TryErrorBoundary_deep_dive_performance-optimization"
    ],
    "related_functions": [],
    "usage_patterns": [
      "async-operations"
    ],
    "cross_references": [
      "TryErrorBoundary_deep_dive_advanced-usage-patterns",
      "fromThrown_deep_dive_advanced-usage-patterns",
      "function_Component",
      "function_clear",
      "isTryError_deep_dive_advanced-usage-patterns",
      "wrapError_deep_dive_advanced-usage-patterns"
    ]
  },
  "hash": "b1697b86953ef7328f445714403c1539"
}